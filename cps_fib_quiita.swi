/**
もっと非Prolog的Prologプログラミング
=====

2014/12/05 @suharahiromichi

この文章のソースコードは以下にあります。
  


2日目のmandel59氏による「非Prolog的Prologプログラミング」では、
フィボナッチ数列を例にPureな関数型言語をPrologに変換する説明がありました。

フィボナッチ数列の計算といえば、忘れてはいけないのは、
継続渡しスタイル（CPS）での計算ですね。
末尾呼び出し(Tail call)、あるいは、末尾再帰(Tail recursion)の
かたちで実装することで、いろいろとおもしろいことがあります。

Prologでこれをやってみよう、というのが今日の話題です。
*/

/**
2日目のプログラムを再掲します。

このプログラムでは、
再帰呼び出し ```f(N1, Y1)``` と ```f(N2, Y2)``` が
```f(N, Y)``` の定義の節の途中に入っています。

これは、末尾再帰ではない、ということです。
*/

f(0, 0).
f(1, 1).
f(N, Y) :-
        N > 1,
        !,
        N1 is N - 1,
        f(N1, Y1),
        N2 is N - 2,
        f(N2, Y2),
        Y is Y1 + Y2.

/**
次に、Schemeで書いたCPSでのフィボナッチ数列のプログラムを示します。

http://d.hatena.ne.jp/nozom/20061014/1160814110

を参考にさせていただきました。
*/

/**
```scm

(define (fib_cps n k)
  (if (or (= n 1) (= n 2))
      (k 1)
      (fib_cps (- n 1)
               (lambda (v1)
                 (fib_cps (- n 2)
                          (lambda (v2)
                            (k (+ v1 v2))))))))
```

Prologと違って入れ子が深いので(!?)解りにくいですが、
2箇所ある ```(fib_cps ...)``` の呼び出しのどちらも、
その結果 (```(fib_cps ...)``` の値) に対して計算を施してい **ない**
ことに注意してください。つまり、再帰的に呼び出された関数の結果は、
なにもせずに、上位（呼び出し元）に戻されます。

なにもせずに戻すだけならば、再帰呼び出しである必要はなく、
ループでよいとにになるわけです…。この話の続きは別の誰かがしてくれるでしょう。
*/

/**
さて、このSchemeのプログラムを2日目と同様に、Prologに書き直してみましょう。

Prologには「lambda」がないので、
q1とq2という述語を定義しなければいけなくなりました。
高階呼び出しは ```call``` を明示的に書かなければいけません。

そして、再帰呼び出しは、必ず節の最後にあることがわかるでしょうか。
*/

fib_cps(1, K, R) :- !,
        call(K, 1, R).
fib_cps(2, K, R) :- !,
        call(K, 1, R).
fib_cps(N, K, R) :-
        N1 is N - 1,
        fib_cps(N1, q1(K, N), R).
 
q1(K, N, V, R) :-
        N2 is N - 2,
        fib_cps(N2, q2(K, V), R).
q2(K, N, V, R) :-
        V1 is N + V,
        call(K, V1, R).

fib_cps(N, R) :-
        fib_cps(N, id, R).
id(A, A).

go :-
        f(10, R1),
        fib_cps(10, R2),
        write(R1), nl,
        write(R2), nl.

/**
では、実行してみましょう。

```
% swipl -f cps_fib_quiita.swi

?- go.
55
55
true .
```  
*/
 
/**
最後に、奇特なひとならば、
一般的な関数と、CPSスタイルとが「本当に」おなじ結果になるのかと、
疑うでしょう。これを示すのは残念ながら、Prologの世界を越えてしまいます。

興味のあるかたは、

http://qiita.com/suharahiromichi/items/f07f932103c28f36dd0e

を参照してください。Prologとは別の定理証明言語を使用してそれを「証明」しています。
*/

/* END */
