/**
PrologのCutとリファクタリングの話
==============

2014/06/23 @suharahiromichi



Prologのコードにリファクタリングを通して、
Cutの意味、Prologの手続的意味の説明をする。
*/

/**
# もとのプログラム

もとのプログラムは、次のようなもので、大学の課題だったようだ。

ストリームから項を入力して、引数で与えられた項とマッチする項だけを
印刷するという問題である。  
*/

findallterm(Term) :-
        read(Term0),
        process(Term0, Term).

process(end_of_file, _) :- !.
process(Term0, Term) :-
        (not(Term0 = Term), !;
         write(Term0 ), nl),
        findallterm(Term).

/**
このプログラムが解りにくいのは、notとcutとorが連続していることである。C言語の

    (Term0 != Term) || write(Term0)

に似ているというより、まったくそのもので、

    「!=」が成立しなければ（つまり「=」なら）、writeする。

という失礼ながら、Cプログラマでも駄目出しされそうである。
*/

/**
# ORをやめる

まず、説明の都合から頭部パターンマッチングをやめ、
さらにOR（「;」）をやめてみる。
*/
findallterm1(Term) :-
        read(Term0),
        process1(Term0, Term).

process1(Term0, _) :-
        Term0 = end_of_file, !,
        true.
process1(Term0, Term) :-
        not(Term0 = Term), !,
        findallterm1(Term).
process1(Term0, Term) :-
        write(Term0 ), nl,
        findallterm1(Term).

/**
# NOTをやめる

processの第2節と第3節を入れ替えることで、notが止められる。
*/
findallterm2(Term) :-
        read(Term0),
        process2(Term0, Term).

process2(Term0, _) :-
        Term0 = end_of_file, !,
        true.
process2(Term0, Term) :-
        Term0 = Term, !,
        write(Term0 ), nl,
        findallterm2(Term).
process2(Term0, Term) :-
        findallterm2(Term).

/**
Process2をみると、

     P :- Q1, !, R1.
     P :- Q2, !, R2.
     R :- S.

の形式になっていて、これは、Prologのcutを含む節の一般的なかたちである。

          if Q1 then R1
     else if Q2 then R3
     else S

という、if-then-elseのかたちに他ならない。  
*/

/**
# if-then-else (Q -> R ; S) にする

大抵のProlog処理系は「if Q then R else S」
を表すメタ述語を持っているから、これを使ってみる。
*/
findallterm3(Term) :-
        read(Term0),
        (Term0 = end_of_file ->
            true;
         Term0 = Term ->
            write(Term0 ), nl,
            findallterm3(Term);
         findallterm3(Term)).

/**
これは、ほとんど手続型言語といえそうである。
*/
  
/**
# 頭部パターンマッチングを使う

前にもどって、頭部パターンマッチングをつかってみよう。
Term0 = end_of_file はもちろん、
Term0 = Term もパターンマッチングで済む。
  */
findallterm4(Term) :-
        read(Term0),
        process4(Term0, Term).

process4(end_of_file, _) :- !.
process4(Term, Term) :- !,
        write(Term), nl,
        findallterm4(Term).
process4(_, Term) :-
        findallterm4(Term).

/**
findallterm(Term) の呼び出し（再帰呼出）が2箇所になったのが気になるかもしれない。
しかし、もともと Term0=Termが成立しても、そうでなくても、再帰を実行するのだから、
2箇所で呼び出すほうが本質的と考えられる。もちろんオーバーヘッドはない。

たとえば、マッチした最初のひとつで終わるとか、たかだが3個だけ出力するといった
具合に「仕様変更」が生じた場合には、このほうが対応し易いはずだ。
*/

/* END */

